<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0"/>
<title>이미지 이어붙이기 v3.7 (백그라운드+취소+UI복원)</title>
<style>
/* ===== 공통 UI ===== */
body{font-family:"Pretendard","Segoe UI",sans-serif;background:#1e1e1e;color:#f0f0f0;margin:0;padding:20px;}
h1{text-align:center;font-weight:600;margin-bottom:10px;}
.container{max-width:900px;margin:auto;}
.option-box{background:rgba(50,50,50,0.8);backdrop-filter:blur(6px);padding:15px 20px;border-radius:12px;margin-bottom:15px;box-shadow:0 0 10px rgba(0,0,0,0.3);}
button,input,select{background:#333;color:#eee;border:none;border-radius:8px;padding:6px 10px;margin:4px;transition:.15s;}
button:hover{background:#555;cursor:pointer;}
button.active{background:#666;color:#fff;}
small.muted{color:#aaa;}
.thumb-list{display:flex;flex-wrap:wrap;gap:8px;margin-top:10px;}
.thumb{position:relative;width:120px;height:90px;overflow:hidden;border:2px solid #555;border-radius:6px;user-select:none;}
.thumb img{width:100%;height:100%;object-fit:cover;transform-origin:center center;pointer-events:none;}
.thumb .index-label{position:absolute;top:3px;left:4px;background:rgba(0,0,0,.7);padding:1px 4px;font-size:12px;border-radius:3px;}
.thumb .btns{position:absolute;right:2px;bottom:2px;display:flex;gap:2px;}
.thumb button.small{padding:2px 4px;font-size:10px;}
canvas{max-width:100%;border:1px solid #666;border-radius:8px;margin-top:10px;}
#timer{text-align:center;color:#ddd;margin-top:6px;min-height:20px;}
#statusLine{text-align:center;margin:8px 0;color:#ccc;}
#pasteHint{text-align:center;color:#888;font-size:14px;}

/* ===== 로딩 오버레이 & GIF (400x268 고정, 비율 유지) ===== */
#loadingOverlay{position:fixed;inset:0;background:rgba(0,0,0,.72);display:none;flex-direction:column;justify-content:center;align-items:center;z-index:999;text-align:center;padding:16px;}
#loadingOverlay img{width:400px;height:268px;object-fit:contain;margin-bottom:12px;image-rendering:auto;}
#loadingOverlay .msg{font-size:18px;}
#loadingOverlay .dots::after{content:'...';animation:dots 1s steps(3,end) infinite;}
@keyframes dots{0%{content:'';}33%{content:'.';}66%{content:'..';}100%{content:'...';}}

/* ===== 토스트 ===== */
#toast{position:fixed;bottom:30px;left:50%;transform:translateX(-50%);background:#333;padding:10px 20px;border-radius:6px;color:#fff;display:none;z-index:1000;}

/* ===== 도움말 툴팁 ===== */
.help{display:inline-block;margin-left:6px;background:#2a2a2a;border:1px solid #666;border-radius:50%;width:18px;height:18px;line-height:18px;text-align:center;font-size:12px;color:#fff;cursor:help;}
.help:hover{background:#3a3a3a;}
#advanced{display:none;margin-top:10px;}
.toggleBtn{background:#2a2a2a;border:1px solid #666;}

/* ===== 상단 모드 버튼 ===== */
#modeBtn{float:right;background:#2a2a2a;border:1px solid #555;}
</style>
</head>
<body>
<div class="container">
  <h1>이미지 이어붙이기 v3.7</h1>
  <div id="statusLine">모드: 세로 | 폭: 자동 | 형식: PNG | 메타 유지</div>
  <button id="modeBtn">현재: 세로모드 🔽</button>

  <!-- ① 업로드 & 순서 -->
  <div class="option-box">
    <h3>① 이미지 업로드 및 순서 설정</h3>
    <input type="file" id="fileInput" multiple accept="image/*"><br />
    <small class="muted">썸네일 ↻ 회전 / ❌ 삭제 / 드래그로 순서 변경 가능</small><br />
    <div id="pasteHint">💡 Ctrl+V로 붙여넣기 가능 (iOS Safari는 지원되지 않습니다)</div>
    <button id="sortName">이름순 정렬</button>
    <button id="sortNameReverse">역순 정렬</button>
    <div id="thumbContainer" class="thumb-list"></div>
  </div>

  <!-- ② 옵션 -->
  <div class="option-box">
    <h3>② 옵션 설정</h3>

    <div>
      <label>가로 크기 (폭 기준):</label>
      <!-- 초기 활성화: 자동 -->
      <button class="widthBtn active" data-width="auto">자동</button>
      <button class="widthBtn" data-width="720">720</button>
      <button class="widthBtn" data-width="1280">1280 (추천)</button>
      <button class="widthBtn" data-width="1920">1920 (추천)</button>
      <button class="widthBtn" data-width="2560">2560</button>
      <button class="widthBtn" data-width="3840">3840</button>
      <input type="number" id="customWidth" placeholder="수동입력(px)" style="width:120px" />
    </div>

    <div>
      <label>비율 조정 방식:</label>
      <label><input type="radio" name="scaleMode" value="keep" checked> 비율 유지 (확대/축소)</label>
      <label><input type="radio" name="scaleMode" value="stretch"> 폭 강제 맞춤 (비율 무시)</label>
    </div>

    <div>
      <label>이미지 간격(px):</label>
      <input type="number" id="gapInput" value="0" min="0" style="width:70px" />
    </div>

    <div>
      <label>출력 형식:</label>
      <label><input type="radio" name="format" value="image/png" checked> PNG</label>
      <label><input type="radio" name="format" value="image/jpeg"> JPEG</label>
    </div>

    <button id="toggleAdvanced" class="toggleBtn">고급 옵션 보기 ▼</button>
    <div id="advanced">
      <label><input type="checkbox" id="stripMeta"> 메타데이터 제거 (EXIF, GPS 등)</label>
      <span class="help" title="브라우저에서 Canvas로 저장하면 일반적으로 EXIF/GPS는 제거됩니다. 이 옵션은 색공간/회전정보 등 예외를 추가로 제거하려는 보안 목적입니다.">❔</span>
    </div>
  </div>

  <!-- ③ 결과 -->
  <div class="option-box">
    <h3>③ 결과</h3>
    <button id="mergeBtn">이미지 합치기</button>
    <button id="cancelBtn" disabled>취소</button>
    <button id="downloadBtn" disabled>다운로드</button>
    <div id="timer"></div>
    <canvas id="resultCanvas"></canvas>
    <canvas id="previewCanvas"></canvas>
  </div>
</div>

<!-- 로딩 오버레이 (GIF + 문구 복원) -->
<div id="loadingOverlay">
  <img src="loading.gif" alt="loading gif (400x268)"/>
  <div class="msg">가은이가 열심히 만들고 있어요! ✨ <span class="dots"></span></div>
</div>

<!-- 토스트 -->
<div id="toast"></div>

<script>
/* ===== 전역 상태 ===== */
const fileInput = document.getElementById('fileInput');
const thumbContainer = document.getElementById('thumbContainer');
const modeBtn = document.getElementById('modeBtn');
const statusLine = document.getElementById('statusLine');
const mergeBtn = document.getElementById('mergeBtn');
const cancelBtn = document.getElementById('cancelBtn');
const downloadBtn = document.getElementById('downloadBtn');
const timerEl = document.getElementById('timer');
const resultCanvas = document.getElementById('resultCanvas');
const rctx = resultCanvas.getContext('2d');
const previewCanvas = document.getElementById('previewCanvas');
const pctx = previewCanvas.getContext('2d');
const loadingOverlay = document.getElementById('loadingOverlay');
const toast = document.getElementById('toast');
const advBox = document.getElementById('advanced');

let images = [];                 // {src, name, rotation}
let mode = 'vertical';           // 'vertical' | 'horizontal'
let selectedWidth = 'auto';      // 'auto' | number
let selectedFormat = 'image/png';
let stripMeta = false;
let currentWorker = null;        // Web Worker 핸들
let isMerging = false;

/* ===== 헬퍼 ===== */
function showToast(msg){
  toast.textContent = msg; toast.style.display='block';
  setTimeout(()=>toast.style.display='none', 2000);
}
function updateStatus(){
  const w = (selectedWidth === 'auto') ? '자동' : (selectedWidth + 'px');
  const m = (mode === 'vertical') ? '세로' : '가로';
  const f = (selectedFormat === 'image/png') ? 'PNG' : 'JPEG';
  const meta = stripMeta ? '메타 제거' : '메타 유지';
  statusLine.textContent = `모드: ${m} | 폭: ${w} | 형식: ${f} | ${meta}`;
}
function setBusy(b){
  isMerging = b;
  mergeBtn.disabled = b;
  cancelBtn.disabled = !b;
  downloadBtn.disabled = b; // 병합 끝나기 전엔 비활성
  loadingOverlay.style.display = b ? 'flex' : 'none';
}

/* ===== 모드 전환 ===== */
modeBtn.onclick = () => {
  mode = (mode === 'vertical') ? 'horizontal' : 'vertical';
  modeBtn.textContent = (mode === 'vertical') ? '현재: 세로모드 🔽' : '현재: 가로모드 ▶️';
  updateStatus();
};

/* ===== 가로폭 버튼 ===== */
document.querySelectorAll('.widthBtn').forEach(btn=>{
  btn.addEventListener('click', ()=>{
    selectedWidth = (btn.dataset.width === 'auto') ? 'auto' : parseInt(btn.dataset.width);
    document.querySelectorAll('.widthBtn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    updateStatus();
  });
});

/* ===== 포맷 선택 ===== */
document.querySelectorAll('input[name="format"]').forEach(r=>{
  r.addEventListener('change', ()=>{
    selectedFormat = document.querySelector('input[name="format"]:checked').value;
    updateStatus();
  });
});

/* ===== 고급 옵션 토글/체크 ===== */
document.getElementById('toggleAdvanced').onclick = ()=>{
  advBox.style.display = (advBox.style.display === 'none' || advBox.style.display === '') ? 'block' : 'none';
};
document.getElementById('stripMeta').onchange = (e)=>{ stripMeta = e.target.checked; updateStatus(); };

/* ===== 업로드 (총합 용량만 제한) ===== */
fileInput.addEventListener('change', ()=>{
  const files = Array.from(fileInput.files);
  const totalMB = files.reduce((s,f)=>s+f.size,0)/(1024*1024);
  const MAX_TOTAL = 300;
  if(totalMB > MAX_TOTAL){
    alert(`총 용량이 너무 큽니다 (≤ ${MAX_TOTAL}MB). 현재 ${totalMB.toFixed(1)}MB`);
    return;
  }
  images = [];
  files.forEach(file=>{
    const r = new FileReader();
    r.onload = e=>{
      images.push({src:e.target.result,name:file.name,rotation:0});
      renderThumbs();
    };
    r.readAsDataURL(file);
  });
});

/* ===== 썸네일 렌더링/정렬/드래그/회전/삭제 ===== */
function renderThumbs(){
  thumbContainer.innerHTML='';
  images.forEach((imgObj,i)=>{
    const div=document.createElement('div'); div.className='thumb'; div.draggable=true; div.dataset.index=i;
    const img=document.createElement('img'); img.src=imgObj.src; img.style.transform=`rotate(${imgObj.rotation}deg)`;
    const label=document.createElement('div'); label.className='index-label'; label.textContent=i+1;
    const btns=document.createElement('div'); btns.className='btns';
    const rot=document.createElement('button'); rot.textContent='↻'; rot.className='small';
    rot.onclick=()=>{ imgObj.rotation=(imgObj.rotation+90)%360; renderThumbs(); };
    const del=document.createElement('button'); del.textContent='❌'; del.className='small';
    del.onclick=()=>{ images.splice(i,1); renderThumbs(); };
    btns.append(rot,del);
    div.append(img,label,btns);
    thumbContainer.append(div);
    // 드래그 순서 변경
    div.addEventListener('dragstart',e=>e.dataTransfer.setData('text/plain',i));
    div.addEventListener('dragover',e=>e.preventDefault());
    div.addEventListener('drop',e=>{
      e.preventDefault();
      const from=parseInt(e.dataTransfer.getData('text/plain'));
      const to=i;
      if(from!==to){ const t=images.splice(from,1)[0]; images.splice(to,0,t); renderThumbs(); }
    });
  });
}
document.getElementById('sortName').onclick = ()=>{ images.sort((a,b)=>a.name.localeCompare(b.name,'ko')); renderThumbs(); showToast('이름순 정렬 완료'); };
document.getElementById('sortNameReverse').onclick = ()=>{ images.sort((a,b)=>b.name.localeCompare(a.name,'ko')); renderThumbs(); showToast('역순 정렬 완료'); };

/* ===== 클립보드 붙여넣기 (Ctrl+V) ===== */
document.addEventListener('paste', e=>{
  const items = e.clipboardData?.items; if(!items) return;
  const before = images.length;
  for(const item of items){
    if(item.type.startsWith('image/')){
      const blob=item.getAsFile();
      const r=new FileReader();
      r.onload=ev=>{
        images.push({src:ev.target.result,name:'clipboard_'+images.length+'.png',rotation:0});
        renderThumbs();
        if(images.length>before) showToast('클립보드 이미지 추가됨');
      };
      r.readAsDataURL(blob);
    }
  }
});

/* ===== 병합 (OffscreenCanvas + Web Worker) ===== */
mergeBtn.addEventListener('click', async ()=>{
  if(images.length===0) return alert('이미지를 먼저 업로드하세요.');
  if(isMerging) return;

  // 입력값 수집
  const gap = parseInt(document.getElementById('gapInput').value)||0;
  const custom = parseInt(document.getElementById('customWidth').value);
  const scaleMode = document.querySelector('input[name="scaleMode"]:checked').value; // 'keep' | 'stretch'
  const format = selectedFormat; // 'image/png' | 'image/jpeg'

  setBusy(true);
  timerEl.textContent = '준비 중...';

  // 이미지를 미리 로드해서 최대 너비 산출
  const bitmaps = []; // 메인 스레드에선 실제 로딩 안함(폭 계산만), 워커가 진짜 렌더링
  let tempMaxW = 0;
  for(const img of images){
    // 폭 계산을 위한 간단 로딩
    const el = new Image();
    const p = new Promise(res=>{ el.onload=()=>res(el.width); el.src=img.src; });
    const w = await p; tempMaxW = Math.max(tempMaxW, w);
  }
  let canvasWidth = (selectedWidth==='auto') ? tempMaxW : selectedWidth;
  if(custom>0) canvasWidth = custom;

  // 워커 생성 (Blob URL)
  const workerCode = `
    self.onmessage = async (e) => {
      const {images, mode, scaleMode, gap, canvasWidth, format} = e.data;
      try{
        // 이미지 로드 (ImageBitmap)
        const loaded = [];
        for (let i=0;i<images.length;i++){
          const src = images[i].src;
          const resp = await fetch(src);
          const blob = await resp.blob();
          const bmp = await createImageBitmap(blob);
          loaded.push({bmp, w:bmp.width, h:bmp.height});
          self.postMessage({type:'progress', i:i+1, total:images.length, phase:'load'});
        }

        // 스케일 계산
        const scaled = [];
        for (let i=0;i<loaded.length;i++){
          let w = loaded[i].w, h = loaded[i].h;
          if (scaleMode==='keep'){
            const s = canvasWidth / w; w = w * s; h = h * s;
          } else if (scaleMode==='stretch'){
            w = canvasWidth; // h는 그대로(수직 스케일 유지)
          }
          scaled.push({bmp:loaded[i].bmp, w, h});
        }

        // 캔버스 크기 계산
        let cw, ch;
        if (mode==='vertical'){
          cw = canvasWidth;
          ch = scaled.reduce((s,v)=>s+v.h,0) + gap*(scaled.length-1);
        } else {
          ch = Math.max(...scaled.map(v=>v.h));
          cw = scaled.reduce((s,v)=>s+v.w,0) + gap*(scaled.length-1);
        }

        const off = new OffscreenCanvas(cw, ch);
        const ctx = off.getContext('2d', { alpha: false, desynchronized: true });
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0,0,cw,ch);

        // 그리기
        let pos = 0;
        for (let i=0;i<scaled.length;i++){
          const s = scaled[i];
          if (mode==='vertical'){
            ctx.drawImage(s.bmp, 0, pos, s.w, s.h);
            pos += s.h + gap;
          } else {
            ctx.drawImage(s.bmp, pos, 0, s.w, s.h);
            pos += s.w + gap;
          }
          self.postMessage({type:'progress', i:i+1, total:scaled.length, phase:'draw'});
        }

        // 결과 Blob
        const blob = await off.convertToBlob({ type: format, quality: 1.0 }); // 무손실 지향
        self.postMessage({type:'done', blob, width: cw, height: ch}, [blob]);
      } catch(err){
        self.postMessage({type:'error', message: String(err)});
      }
    };
  `;
  const blobURL = URL.createObjectURL(new Blob([workerCode], {type:'application/javascript'}));
  currentWorker = new Worker(blobURL);
  URL.revokeObjectURL(blobURL);

  currentWorker.onmessage = async (ev)=>{
    const data = ev.data;
    if(data.type==='progress'){
      // 로드/드로우 진행률 업데이트
      const phaseTxt = (data.phase==='load') ? '불러오는 중' : '그리는 중';
      timerEl.textContent = `${phaseTxt} ${data.i} / ${data.total}`;
    }
    else if(data.type==='done'){
      // 결과 수신
      const { blob, width, height } = data;
      // 메인 캔버스에 그리기
      resultCanvas.width = width; resultCanvas.height = height;
      const bmp = await createImageBitmap(blob);
      rctx.clearRect(0,0,width,height);
      rctx.drawImage(bmp,0,0);

      // 미리보기 축소
      const scale = Math.min(600/width, 300/height, 1);
      previewCanvas.width = Math.max(1, Math.floor(width*scale));
      previewCanvas.height = Math.max(1, Math.floor(height*scale));
      pctx.clearRect(0,0,previewCanvas.width,previewCanvas.height);
      pctx.drawImage(bmp,0,0,previewCanvas.width,previewCanvas.height);

      // 다운로드 준비 (메타 옵션 적용)
      downloadBtn.disabled = false;
      const d = new Date();
      const stamp = `${d.getFullYear()}${String(d.getMonth()+1).padStart(2,'0')}${String(d.getDate()).padStart(2,'0')}_${String(d.getHours()).padStart(2,'0')}${String(d.getMinutes()).padStart(2,'0')}`;
      const name = `merged_${stamp}` + (selectedFormat==='image/png'?'.png':'.jpg');

      downloadBtn.onclick = async ()=>{
        if(stripMeta){
          // 추가 재인코딩(보안 확신용) — 화질 유지(1.0)
          const c2 = document.createElement('canvas'); c2.width = width; c2.height = height;
          const x2 = c2.getContext('2d');
          x2.drawImage(resultCanvas,0,0);
          const blob2 = await new Promise(res=>c2.toBlob(res, selectedFormat, 1.0));
          const url2 = URL.createObjectURL(blob2);
          const a = document.createElement('a'); a.download = name; a.href = url2; a.click();
          URL.revokeObjectURL(url2);
        } else {
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a'); a.download = name; a.href = url; a.click();
          URL.revokeObjectURL(url);
        }
      };

      const elapsedTxt = ''; // 워커 내에서 정확한 시간 측정은 생략(진행률로 대체)
      timerEl.textContent = `완료 | ${images.length}장 | 폭 ${width}px | ${mode==='vertical'?'세로':'가로'} | ${selectedFormat.split('/')[1].toUpperCase()}`;
      setBusy(false);
      document.getElementById('resultCanvas').scrollIntoView({behavior:'smooth'});
      currentWorker.terminate(); currentWorker=null;
    }
    else if(data.type==='error'){
      alert('오류: ' + data.message);
      setBusy(false);
      if(currentWorker){ currentWorker.terminate(); currentWorker=null; }
    }
  };

  currentWorker.postMessage({
    images, mode, scaleMode, gap, canvasWidth, format
  });
});

/* ===== 취소(Abort) ===== */
cancelBtn.addEventListener('click', ()=>{
  if(currentWorker){
    currentWorker.terminate();
    currentWorker = null;
  }
  setBusy(false);
  timerEl.textContent = '사용자가 취소했습니다.';
});

/* ===== 초기 상태 표시 ===== */
updateStatus(); // 모드/폭/형식/메타
// '자동' 가로폭 버튼은 이미 .active로 표시됨
</script>
</body>
</html>
